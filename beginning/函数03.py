# -*- coding:utf-8 -*-
"""
作者: gaoxu
日期: 2021年08月23日
"""
import random

格式：

def 函数名(a, b=6):     b是有默认值的

，默认值参数可以通过关键字直接传值，原因是默认参数的顺序都是固定的
代码
传递列表进入函数就是传了本身，并不是传值，外部的列表不用传递也可以直接在函数中使用

可变参数 * args


def get_sum(*args):   *args可以接收多个参数并封装成元组

（装包）
代码
在调用的时候实参加 *，表示拆包
a = [1, 2, 3, 4, 5]
get_sum(*a)

可变参数 ** kwargs
必须用关键字的形式调用，kwargs是一个字典
也是装包


def show_books(**kwargs):
    print(kwargs)


'''
conclude: if there's a **kwargs ,it must be the last one.
           if there's a *args ,it must be front of defaults.
'''

show_books(bookname='西游记', bookname2='红楼梦')
book = {'bookname': 'xyj', 'bookname2': 'hlm'}
show_books(**book)
# 一个星星拆元组列表的包，两个星星拆字典

可变参数 * args
可变参数 ** kwargs
同时存在

用return来返回函数的返回值且外界需要接收，和c一样
python可以返回多个值，会封装成一个元组；所以可以用两个值去接收

# 全局变量和局部变量（同样先找局部变量再找全局变量）
# 函数外的变量就是全局变量
# 若函数内部要改变全区变量，需要加global关键字，否则不能改变
'''
不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。
可变数据类型    ：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。
总结：不可变数据类型更改后地址发生改变，可变数据类型更改地址不发生改变(集合、列表、元组可变)
'''
# 列表等全局变量在函数内部操作时不用加gobal，因为是可变的

# 函数地注释（文档说明）
# 在第一行打三引号回车即可

# 引用
# sys.getrefcount()函数可以求出指向这个空间地指针有多少个  ps：这个函数本身也是个指针
# a=b  c=b  只是给了引用地址，如果所用指针都没了，那么就会被垃圾回收
# 可以用id（）函数判断两个变量是否为一个值的引用
# gettrefcount()函数需要用到import sys


# 闭包装饰器
# 函数 local（）表示查看函数中的局部变量，以字典的形式返回
#  在函数嵌套的时候内部函数可以使用外部函数的变量，但不能修改，修改记住只能是自己的才有修改的权限
# 若想修改，则需要在内部函数中添加 nonlocal，而不是global（虽然不会报错）
# 变量搜索顺序 ： 内层函数--外层函数--全局函数--系统builtins
# 闭包：
'''
1.嵌套函数
2.内部函数引用了外部函数的变量
3.返回值是内部函数
主要是装饰器使用
格式如下
'''


def out():
    a = 5

    def inner():
        b = a + 1
        print(b)

    return inner  # 返回的是地址


r = out(5)

# 查看全局变量使用globals（）  //返回值是一个字典
# 查看局部变量使用locals（）  //返回值是一个字典        注意内部函数也可以看成一个局部变量


# 装饰器 详见demo
# 装饰器的出现是因为面向对象需要遵循 开放封闭 的原则下扩展了函数的功能 ，也就是不允许改动功能已经完成的代码模块，而只允许进行添加和修饰，闭包就是实现装饰器的工具
# 功能：1 引入日志  2.执行函数时间统计 3.执行函数前的预备处理 4执行函数后的清理功能 5.权限校验 6，缓存

# 匿名函数
# 用lambda关键词可以创建小型函数（具体为匿名函数），这种写法得名于省略了用def关键字定义函数的标准步骤
其实就是不配有名字而已
# 唯一语法结构：
lambda 参数列表: 运算表达式  # 运算表达式就是return的结果
# 由于lambda没有函数名，所以要有变量接收
result = lambda x,y: x + 1+y
result(1,2)                # 调用方式相当于是函数叫result

#函数高阶
#变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，同样，我们还可以
#把一个函数当作另一个函数的返回值。这样的使用方式为      函数高阶
# 系统高阶函数:max min sorted具体见 demo(advanced function)
